<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>quiz2_574</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="quiz2_574_files/libs/clipboard/clipboard.min.js"></script>
<script src="quiz2_574_files/libs/quarto-html/quarto.js"></script>
<script src="quiz2_574_files/libs/quarto-html/popper.min.js"></script>
<script src="quiz2_574_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="quiz2_574_files/libs/quarto-html/anchor.min.js"></script>
<link href="quiz2_574_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="quiz2_574_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="quiz2_574_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="quiz2_574_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="quiz2_574_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<section id="quiz-2---574" class="level1">
<h1>Quiz 2 - 574</h1>
<section id="probabilistic-forecasting" class="level2">
<h2 class="anchored" data-anchor-id="probabilistic-forecasting">Probabilistic Forecasting</h2>
<ul>
<li>We have been dealing with <strong>point forecasts</strong> (modelling averages)</li>
<li>Want to estimate the <strong>uncertainty</strong> of our forecasts
<ul>
<li>or the extreme (e.g.&nbsp;90% or 95% quantiles)
<ul>
<li>example: find upper quantile of electricity demand so that we can plan for the maximum demand</li>
</ul></li>
<li>or predict the variance of the forecast (how volatile a metric will be in the future)</li>
</ul></li>
</ul>
<section id="analytical" class="level3">
<h3 class="anchored" data-anchor-id="analytical">Analytical</h3>
<ul>
<li>Assume distribution of forecasts are normal</li>
</ul>
<p><span class="math display">\[
\hat{y}_{T+h|T} \pm c \hat{\sigma}_{h}
\]</span></p>
<ul>
<li><span class="math inline">\(\hat{\sigma}_{h}\)</span> is the standard deviation of the forecast</li>
<li><span class="math inline">\(c\)</span>: coverage factor (e.g.&nbsp;1.96 for 95% confidence interval)</li>
</ul>
<p><span class="math display">\[
\hat{\sigma}_{h} = \sqrt{\frac{1}{T-K}\sum_{t=1}^{T} e_{t}^{2}}
\]</span></p>
<ul>
<li><p>Focus is finding <span class="math inline">\(\hat{\sigma}_{h}\)</span></p>
<ul>
<li><span class="math inline">\(K\)</span>: number of parameters</li>
<li><span class="math inline">\(T\)</span>: total length of time series</li>
<li><span class="math inline">\(e_{t} = y_{t} - \hat{y}_{t|t-1}\)</span></li>
</ul></li>
<li><p>Methods that have been derived mathematically:</p>
<table class="table">
<colgroup>
<col style="width: 18%">
<col style="width: 81%">
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Forecast sd</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Mean</td>
<td><span class="math inline">\(\hat{\sigma}_{h} = \hat{\sigma_1} \sqrt{1 + \frac{h}{T}}\)</span></td>
</tr>
<tr class="even">
<td>Naive</td>
<td><span class="math inline">\(\hat{\sigma}_{h} = \hat{\sigma_1} \sqrt{h}\)</span></td>
</tr>
<tr class="odd">
<td>Seasonal Naive</td>
<td>$_{h} = $</td>
</tr>
<tr class="even">
<td>Drift</td>
<td><span class="math inline">\(\hat{\sigma}_{h} = \hat{\sigma_1} \sqrt{h(1+\frac{h}{T})}\)</span></td>
</tr>
</tbody>
</table></li>
<li><p><em>Recall: <span class="math inline">\(h\)</span> is the forecast horizon (steps ahead), <span class="math inline">\(m\)</span> is the seasonal period</em></p></li>
</ul>
<p><img src="../images/5_normal_plot.png" width="500"></p>
</section>
<section id="simulation-and-bootstrapping" class="level3">
<h3 class="anchored" data-anchor-id="simulation-and-bootstrapping">Simulation and Bootstrapping</h3>
<ul>
<li>Assume future errors will be similar to past errors</li>
<li>Draw from the distribution of past errors to simulate future errors</li>
</ul>
<p><span class="math display">\[y_{T+h} = \hat{y}_{T+h|T} + \epsilon_{T+h}\]</span></p>
</section>
<section id="quantile-regression" class="level3">
<h3 class="anchored" data-anchor-id="quantile-regression">Quantile Regression</h3>
<ul>
<li>Wish to predict particular quantile instead of mean
<ul>
<li>e.g <span class="math inline">\(q=0.9\)</span> so we expect 90% of the future values to be below the forecast</li>
</ul></li>
<li>Pinball loss/ Quantile loss: <span class="math display">\[
\mathcal{L}=
     \left\{
\begin{array}{ll}
      (1-q)(\hat{y}_{t,q}-y_t) \text{,} \;\; \text{ if } y_t &lt; \hat{y}_{t,q} \\
      q(y_t-\hat{y}_{t,q}) \text{,} \;\;\;\;\;\;\;\;\;\; \text{ if } y_t \ge \hat{y}_{t,q} \\
\end{array}
\right.
\]</span></li>
</ul>
<table class="table">
<colgroup>
<col style="width: 49%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>High Quantile</th>
<th>Low Quantile</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Higher penalty for predicting <strong>OVER</strong></td>
<td>Higher penalty for predicting <strong>UNDER</strong></td>
</tr>
</tbody>
</table>
<section id="quantile-regression-in-pytorch" class="level4">
<h4 class="anchored" data-anchor-id="quantile-regression-in-pytorch">Quantile Regression in PyTorch</h4>
<p>see <a href="https://pages.github.ubc.ca/MDS-2023-24/DSCI_574_spat-temp-mod_instructors/lectures/lecture5_uncertainty.html#quantile-regression">here</a></p>
<p>Quantile loss is not currently a supported criterion in pytorch but it’s easy to define ourselves. We really have two options:</p>
<ul>
<li>Train a network for each quantile we want to predict; or</li>
<li>Train a network to output multiple quantiles at once</li>
</ul>
</section>
</section>
<section id="evaluating-distributional-forecast-accuracy" class="level3">
<h3 class="anchored" data-anchor-id="evaluating-distributional-forecast-accuracy">Evaluating Distributional Forecast Accuracy</h3>
<ul>
<li><p>There are 4 main sources of uncertainty:</p>
<ol type="1">
<li>Random error term</li>
<li>Uncertainty in model parameter estimates</li>
<li>Uncertainty in model selection</li>
<li>Uncertainty about consistency of data generating process in the future</li>
</ol></li>
<li><p>Most methods only consider the first source of uncertainty</p></li>
<li><p>Simulation tries to consider 2 and 3</p></li>
<li><p>4 is practically impossible to consider</p></li>
</ul>
</section>
</section>
<section id="anomaly-detection" class="level2">
<h2 class="anchored" data-anchor-id="anomaly-detection">Anomaly Detection</h2>
<ul>
<li>Outliers are observations that are significantly different from the rest of the data
<ul>
<li>Can be due to measurement error, data entry error, or just unique observations</li>
</ul></li>
</ul>
<section id="rolling-median" class="level3">
<h3 class="anchored" data-anchor-id="rolling-median">Rolling Median</h3>
<ul>
<li><strong>Methodology</strong>:
<ol type="1">
<li>Subtract the rolling median from data (with suitable window size)</li>
<li>Calculate standard deviation of the residuals (<span class="math inline">\(\hat{\sigma_r}\)</span>)</li>
<li>Assume normally distributed residuals then identify outliers as outside the 95% confidence interval (<span class="math inline">\(\pm 1.96 \hat{\sigma_r}\)</span>)</li>
</ol></li>
</ul>
</section>
<section id="stl-decomposition" class="level3">
<h3 class="anchored" data-anchor-id="stl-decomposition">STL Decomposition</h3>
<ul>
<li><strong>Methodology</strong>:
<ol type="1">
<li>Decompose time series to find residuals:
<ul>
<li>Non-seasonal data: use LOESS</li>
<li>Seasonal data: use STL (Seasonal-Trend decomposition using LOESS)</li>
</ul></li>
<li>Calculate <span class="math inline">\(q_{0.1}\)</span> and <span class="math inline">\(q_{0.9}\)</span> of the residuals</li>
<li>Identify outliers as <span class="math inline">\(\pm2 \times (q_{0.9} - q_{0.1})\)</span></li>
</ol></li>
</ul>
</section>
<section id="model-based" class="level3">
<h3 class="anchored" data-anchor-id="model-based">Model-based</h3>
<ul>
<li><strong>Methodology</strong>:
<ol type="1">
<li>Fit a model to the data</li>
<li>Identify outliers as significant deviations from model predictions (e.g.&nbsp;95% confidence interval)</li>
</ol></li>
</ul>
</section>
<section id="ml-approaches" class="level3">
<h3 class="anchored" data-anchor-id="ml-approaches">ML approaches</h3>
<ul>
<li>Train an ML model to predict outliers</li>
<li>A few common packages: pyod, sklearn, luminaire, sklyline, etc.</li>
</ul>
<section id="isolation-forest" class="level4">
<h4 class="anchored" data-anchor-id="isolation-forest">Isolation Forest</h4>
<ul>
<li>Built on basis of decision trees</li>
<li><strong>High-level idea</strong>:
<ul>
<li>randomly select a feature</li>
<li>randomly splits that feature into 2 values</li>
<li>repeat until all data points are isolated</li>
</ul></li>
<li>Less splits to isolate a data point = more likely to be an outlier</li>
<li>Score = [0, 1] where 1 is an outlier, &gt; 0.5 are normal observations.</li>
</ul>
<p><img src="../images/5_isoforest.png" width="450"></p>
</section>
<section id="k-nn" class="level4">
<h4 class="anchored" data-anchor-id="k-nn">K-NN</h4>
<ul>
<li>For each data point, calculate the distance to its k-th nearest neighbor
<ul>
<li>Large distance = outlier</li>
</ul></li>
<li>Supports 3 kNN detectors:
<ol type="1">
<li>Largest: distance to the k-th neighbor</li>
<li>Mean: average distance to k neighbors</li>
<li>Median: median distance to k neighbors</li>
</ol></li>
<li>pyod’s <code>KNN()</code> outlier detection</li>
</ul>
</section>
</section>
<section id="global-vs-local-outliers" class="level3">
<h3 class="anchored" data-anchor-id="global-vs-local-outliers">Global vs Local Outliers</h3>
<ul>
<li><p><strong>Global outliers</strong>: A data point with its value is far outside of the entirety of the data set (e.g., billionaires)</p></li>
<li><p><strong>Local/Contextual outliers</strong>: A data point is considered a contextual outlier if its value significantly deviates from the rest the data points in the same context. (e.g., earning 50K income in a developing countries)</p></li>
</ul>
</section>
</section>
<section id="imputation" class="level2">
<h2 class="anchored" data-anchor-id="imputation">Imputation</h2>
<ul>
<li><strong>Imputation</strong>: Filling in missing values/ outliers in a dataset</li>
<li>Overarching techniques:
<ol type="1">
<li>Remove (<code>.dropna()</code>)</li>
<li>Fill manually based on some expert-interpreted values (<code>.fillna()</code>)</li>
<li>Fill with mean/median/mode (<code>.fillna()</code>)</li>
<li>Fill based on rolling statistic, e.g.&nbsp;rolling mean/median</li>
<li>Polynomial interpolation</li>
<li>Fill based on temporal dependence
<ul>
<li>i.e.&nbsp;use same value from the same period last season, or average of all periods in the past season</li>
</ul></li>
<li>Fill with model fitted values</li>
<li>Use <code>MICE</code> (Multiple Imputation by Chained Equations) from <code>statsmodels</code> or <code>IterativeImputer</code> from <code>sklearn</code>.</li>
</ol></li>
</ul>
</section>
</section>
<section id="deep-learning-with-time-series" class="level1">
<h1>Deep Learning with Time Series</h1>
<ul>
<li><p>Classical time series (ARIMA, Exponential Smoothing) limitations:</p>
<ul>
<li>They are linear models</li>
<li>Inputs must be specified, not learned automatically</li>
<li>Focus on univariate time series (lack support for multivariate time series)</li>
<li>Focus on regression (lack support for classification)</li>
<li>Assumes complete, non-missing data</li>
</ul></li>
<li><p>Deep learning models can address these limitations, as NNs are:</p>
<ul>
<li>robust to noise</li>
<li>can learn complex, non-linear relationships</li>
<li>support multivariate time series</li>
<li>feature learning (learn the inputs)</li>
<li>temporal dependencies can be learned</li>
</ul></li>
</ul>
<section id="neural-networks" class="level3">
<h3 class="anchored" data-anchor-id="neural-networks">Neural Networks</h3>
<ul>
<li>NN allows us so that the features do not need to be ordered
<ul>
<li>e.g.&nbsp;target, lag1. lag2, lag3 is the same as lag2, lag3, target, lag1</li>
</ul></li>
<li>Need to take into account inherent temporal dependencies (approach above does not)</li>
<li>Do something similar like CNN (retain spatial information) but for time series</li>
</ul>
</section>
<section id="convolutional-neural-networks-cnn" class="level3">
<h3 class="anchored" data-anchor-id="convolutional-neural-networks-cnn">Convolutional Neural Networks (CNN)</h3>
<ul>
<li>Can work with 3D data (channels, height, width)</li>
<li>Can also do 2D data (features, time)</li>
<li>Use <code>Conv1D</code> from <code>pytorch</code> to work with time series data
<ul>
<li>Looks at local groups of data (filter of some size)</li>
<li>Missing memory (does not remember previous values, only looks at local groups of data)
<ul>
<li>can be solved with RNN</li>
</ul></li>
</ul></li>
</ul>
<p><img src="../images/6_cnn.gif" width="600"></p>
<p><em>Image with sequence of 20 values, filtered with 4 kernels of size 3</em></p>
<ul>
<li>Then make CNN with optimizer <code>Adam</code> and loss function <code>MSE</code></li>
</ul>
</section>
<section id="recurrent-neural-networks-rnn" class="level3">
<h3 class="anchored" data-anchor-id="recurrent-neural-networks-rnn">Recurrent Neural Networks (RNN)</h3>
<ul>
<li><p>Reasonable results with CNN because preserve structure of data</p></li>
<li><p><strong>Structure</strong>: - Split up and process one time-step at a time</p>
<p><img src="../images/6_classic_nn.png" height="175"> <img src="../images/6_rnn_diag.png" height="175"></p></li>
<li><p>Great video on <a href="https://www.youtube.com/watch?v=LHXXI4-IEns&amp;t=585s">RNNs</a></p></li>
<li><p>Draw back: <strong>Vanishing Gradient Problem</strong></p>
<ul>
<li>Gradient becomes so small that it does not update the weights</li>
<li>Early time steps are not updated (long-term dependencies are not learned), they “forget”</li>
<li>Can be solved with LSTM and GRU</li>
</ul></li>
</ul>
</section>
<section id="long-short-term-memory-lstm" class="level3">
<h3 class="anchored" data-anchor-id="long-short-term-memory-lstm">Long Short-Term Memory (LSTM)</h3>
<p><img src="../images/6_lstm.png" height="175"></p>
<ul>
<li><p>All the yellow boxes (LSTM cells) are identical (same weights and architecture)</p></li>
<li><p><strong>Components</strong>:</p>
<ul>
<li><strong>Cell State</strong>: The horizontal line running through the top of the diagram
<ul>
<li>It runs straight down the entire chain, with only some minor linear interactions</li>
</ul></li>
<li><strong>Forget Gate</strong>: Decides what information to throw away from the cell state</li>
<li><strong>Input Gate</strong>: Decides what new information to store in the cell state</li>
<li><strong>Output Gate</strong>: Decides what to output based on the cell state</li>
</ul></li>
<li><p>GRU is similar to LSTM, but has less parameters and is faster to train</p></li>
</ul>
</section>
<section id="useful-time-series-packages" class="level3">
<h3 class="anchored" data-anchor-id="useful-time-series-packages">Useful Time Series Packages</h3>
<ul>
<li>Prophet: Facebook’s time series forecasting package</li>
<li>GluonTS: alternative to pytorch.</li>
<li>PyTorch Forecasting: built on top of pytorch, but with more focus on time series forecasting.</li>
<li>sktime: scikit-learn for time series data.</li>
<li>Tidyverts: R package for time series forecasting.</li>
</ul>
</section>
<section id="additional-topics" class="level3">
<h3 class="anchored" data-anchor-id="additional-topics">Additional Topics</h3>
<ul>
<li><strong>Heirarchical Time Series</strong>: Forecasting at different levels of aggregation (e.g.&nbsp;product sales at store level, then at regional level, then at national level)
<ul>
<li>Bottom-up: Forecast at the lowest level and aggregate up</li>
<li>Top-down: Forecast at the highest level and disaggregate down</li>
</ul></li>
<li><strong>Multiple Seasonalities</strong>: e.g.&nbsp;daily and weekly seasonality
<ul>
<li>decompose independently</li>
<li>decompose simultaneously (e.g.&nbsp;propher/ statsmodels)</li>
</ul></li>
<li><strong>Multivariate Time Series</strong>: e.g.&nbsp;sales and advertising spend
<ul>
<li>VAR (Vector Auto Regression)</li>
<li>LSTM with multiple inputs</li>
</ul></li>
<li><strong>Explanatory variables</strong>:
<ul>
<li>easy to add features to ML models</li>
<li>ARIMA can but using <code>exog</code> parameter</li>
</ul></li>
<li><strong>Time Series Classification</strong>:
<ul>
<li>Hidden Markov Models</li>
</ul></li>
</ul>
</section>
</section>
<section id="spatial-data" class="level1">
<h1>Spatial Data</h1>
<ul>
<li>Data with location information (Has spacial dependence)</li>
<li><strong>Main Tasks</strong>: Wrangling, Visualization, Modelling</li>
<li><strong>Representation</strong>: Vector, Raster</li>
</ul>
<section id="working-with-vector-data" class="level2">
<h2 class="anchored" data-anchor-id="working-with-vector-data">Working with Vector Data</h2>
<ul>
<li>Collection of discrete locations/ vertices <code>(x, y)</code> to form:
<ul>
<li><strong>Points</strong>: single location</li>
<li><strong>Lines</strong>: series of points</li>
<li><strong>Polygons</strong>: series of lines (closed shape)</li>
</ul></li>
<li>Stored in <code>.shp</code> (shapefile) format
<ul>
<li><code>.shp</code>: geometry</li>
<li><code>.shx</code>: index (how geometry relates to one another)</li>
<li><code>.dbf</code>: attributes (e.g.&nbsp;population, area)</li>
</ul></li>
</ul>
<section id="geopandas-intro" class="level3">
<h3 class="anchored" data-anchor-id="geopandas-intro">Geopandas Intro</h3>
<ul>
<li>To read and write vector data</li>
<li>Built off of <code>pandas</code> and <code>shapely</code></li>
<li>Similar to <code>pandas</code> it has:
<ul>
<li><code>GeoSeries</code>: series of geometries</li>
<li><code>GeoDataFrame</code>: dataframe with geometry column
<ul>
<li>Geometry column contains vector data</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="loading-from-openstreetmap" class="level3">
<h3 class="anchored" data-anchor-id="loading-from-openstreetmap">Loading from OpenStreetMap</h3>
<ul>
<li>It is like the wikipedia of geospacial data</li>
<li>Use <code>osmnx</code> to get data from OpenStreetMap</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> osmnx <span class="im">as</span> ox</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>vancouver <span class="op">=</span> ox.geocode_to_gdf(<span class="st">"Vancouver, Canada"</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>vancouver.plot(edgecolor<span class="op">=</span><span class="st">"0.2"</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># get higher resolution</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>van_bc <span class="op">=</span> gpd.clip(bc, vancouver)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot stanley park in vancouver</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>stanley_park <span class="op">=</span> ox.geocode_to_gdf(<span class="st">"Stanley Park, Vancouver"</span>)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> van_bc.plot(edgecolor<span class="op">=</span><span class="st">"0.2"</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>stanley_park.plot(ax<span class="op">=</span>ax, edgecolor<span class="op">=</span><span class="st">"0.2"</span>, color<span class="op">=</span><span class="st">"tomato"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><img src="../images/7_stanley.png" width="300"></p>
</section>
<section id="wrangling-with-geopandas" class="level3">
<h3 class="anchored" data-anchor-id="wrangling-with-geopandas">Wrangling with Geopandas</h3>
<ul>
<li><strong>Add width to line</strong>: <code>gdf.buffer(2)</code> to add a 2m to left and right of the line (4m total)</li>
<li><strong>Get Length of line</strong>: <code>gdf.length.sum()</code> to get the length of the line
<ul>
<li>Need to convert to linear meters first</li>
</ul></li>
<li><strong>Get Area of polygon</strong>: <code>gdf.area.sum()</code> to get the area of the polygon
<ul>
<li>Need to convert to linear meters first</li>
</ul></li>
<li><strong>Joining</strong>: <code>gpd.sjoin(gdf1, gdf2, how=‘left’, predicate=‘intersects’)</code>
<ul>
<li><code>how</code>: left, right, inner, outer</li>
<li><code>predicate</code>: intersects, contains, within, touches, crosses, overlaps</li>
</ul></li>
<li><strong>Grouping</strong>: <code>gdf.groupby(by=‘column’).sum().sort_values("length", ascending=False)</code></li>
</ul>
</section>
</section>
<section id="working-with-raster-data" class="level2">
<h2 class="anchored" data-anchor-id="working-with-raster-data">Working with Raster Data</h2>
<p><img src="../images/7_raster.png" width="300"></p>
<ul>
<li>Each pixel has 4 bands: Red, Green, Blue, and Infrared</li>
<li><strong>Resolution</strong>: size of each pixel (e.g.&nbsp;1m x 1m)
<ul>
<li>smaller resolution = more detailed</li>
</ul></li>
<li>Most common format: GeoTIFF (<code>.tif</code>)</li>
<li>Use Python library <code>rasterio</code> to read and write raster data</li>
</ul>
</section>
<section id="coordinate-reference-systems-crs" class="level2">
<h2 class="anchored" data-anchor-id="coordinate-reference-systems-crs">Coordinate Reference Systems (CRS)</h2>
<ul>
<li>Typically identified by EPSG (European Petroleum Survey Group) code</li>
<li><strong>Common CRS</strong>:
<ul>
<li><strong>Angular units</strong> (latitude and longitude): <code>EPSG:4326</code></li>
<li><strong>Linear units</strong> (meters): Most common is UTM which is divided into zones. For British Columbia, it’s <code>EPSG:32610</code></li>
<li><strong>Minimize distortion</strong> by choosing the right CRS, for Canada, it’s <code>EPSG:3347</code> (“Lambert projection”)</li>
</ul></li>
<li><strong>Change code in geopandas:</strong><code>gdf.to_crs(“EPSG:3347”)</code></li>
</ul>
</section>
<section id="spatial-visualization" class="level2">
<h2 class="anchored" data-anchor-id="spatial-visualization">Spatial Visualization</h2>
<section id="geopandas-plotting" class="level3">
<h3 class="anchored" data-anchor-id="geopandas-plotting">Geopandas Plotting</h3>
<ul>
<li>Easy to use and quick</li>
</ul>
<ol type="1">
<li>Get data of UBC buildings from <code>osmnx</code></li>
</ol>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> osmnx <span class="im">as</span> ox</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> geopandas <span class="im">as</span> gpd</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>ubc <span class="op">=</span> (ox.features.features_from_place(<span class="st">"University of British Columbia, Canada"</span>,</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>                                tags<span class="op">=</span>{<span class="st">'building'</span>:<span class="va">True</span>}) <span class="co"># Just keep building footprints</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        ...</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="2" type="1">
<li>Get the building footprint of a specific building from its coordinates</li>
</ol>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>point_coord <span class="op">=</span> Point(<span class="op">-</span><span class="fl">123.25203756532703</span>,<span class="fl">49.26314716306668</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>ubc[ubc.contains(point_office)] <span class="co"># get the building that contains the point</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>ubc.loc[<span class="dv">47</span>, <span class="st">"Label"</span>] <span class="op">=</span> <span class="st">"Earth Science Building"</span> <span class="co"># change the label</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="3" type="1">
<li>Add map to the background</li>
</ol>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> contextily <span class="im">as</span> cx</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> (ubc.to_crs(<span class="st">"EPSG:3857"</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>         .plot(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>), column<span class="op">=</span><span class="st">"Label"</span>, legend<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>               edgecolor<span class="op">=</span><span class="st">"0.2"</span>, markersize<span class="op">=</span><span class="dv">200</span>, cmap<span class="op">=</span><span class="st">"rainbow"</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>     )</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>cx.add_basemap(ax, source<span class="op">=</span>cx.providers.OpenStreetMap.Mapnik)  <span class="co"># I'm using OSM as the source. See all provides with ctx.providers</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">"off"</span>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"UBC"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="plotly-express" class="level3">
<h3 class="anchored" data-anchor-id="plotly-express">Plotly Express</h3>
<ul>
<li>To add interactivity to the map</li>
<li>Backed by MapBox (mapping and location data cloud platform)</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plotly.express <span class="im">as</span> px</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate area</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>ubc[<span class="st">"Area"</span>] <span class="op">=</span> ubc.to_crs(epsg<span class="op">=</span><span class="dv">3347</span>).area  <span class="co"># (https://epsg.io/3347)</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Make plot</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> px.choropleth_mapbox(ubc,</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>                            geojson<span class="op">=</span>ubc.geometry,</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>                            locations<span class="op">=</span>ubc.index,</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>                            color<span class="op">=</span><span class="st">"Area"</span>,</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>                            center<span class="op">=</span>{<span class="st">"lat"</span>: <span class="fl">49.261</span>, <span class="st">"lon"</span>: <span class="op">-</span><span class="fl">123.246</span>},</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>                            zoom<span class="op">=</span><span class="fl">12.5</span>,</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>                            mapbox_style<span class="op">=</span><span class="st">"carto-positron"</span>)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>fig.update_layout(margin<span class="op">=</span><span class="bu">dict</span>(l<span class="op">=</span><span class="dv">0</span>, r<span class="op">=</span><span class="dv">0</span>, t<span class="op">=</span><span class="dv">30</span>, b<span class="op">=</span><span class="dv">10</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><img src="../images/8_plotly_c.png" width="500"></p>
</section>
<section id="kepler.gl" class="level3">
<h3 class="anchored" data-anchor-id="kepler.gl">Kepler.gl</h3>
<ul>
<li>Web-based geospatial analysis tool</li>
<li>Even more powerful than Plotly Express</li>
<li>How it works:
<ol type="1">
<li>Create instance of map with <code>keplergl.KeplerGl()</code></li>
<li>Add as much data with <code>.add_data()</code> method</li>
<li>Customize and configure the map using GUI</li>
</ol></li>
</ul>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> keplergl <span class="im">import</span> KeplerGl</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>ubc_map <span class="op">=</span> keplergl.KeplerGl(height<span class="op">=</span><span class="dv">500</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>ubc_map.add_data(data<span class="op">=</span>ubc.copy(), name<span class="op">=</span><span class="st">"Building heights"</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>ubc_map</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>Can also make a 3d map with building heights
<ul>
<li>Load the building heights data</li>
<li>Join the data with the building footprints</li>
<li>Plot the 3d map + addjust the GUI settings</li>
</ul></li>
</ul>
</section>
</section>
<section id="spatial-modeling" class="level2">
<h2 class="anchored" data-anchor-id="spatial-modeling">Spatial Modeling</h2>
<p><img src="../images/8_s_inter_tab.png" width="450"></p>
<p>Source: https://www.neonscience.org/resources/learning-hub/tutorials/spatial-interpolation-basics</p>
<ul>
<li>Two common ways to model spatial data:
<ol type="1">
<li><strong>Spatial interpolation</strong>: use a set of observations in space to estimate the value of a spatial field</li>
<li><strong>Areal interpolation</strong>: project data from one set of polygons to another set of polygons</li>
</ol></li>
<li>“everything is related to everything else, but near things are more related than distant things” (Tobler, 1970)</li>
</ul>
<section id="deterministic-interpolation" class="level3">
<h3 class="anchored" data-anchor-id="deterministic-interpolation">Deterministic Interpolation</h3>
<ul>
<li><p>Use <code>scipy</code> module <code>interpolate</code> to do deterministic interpolation</p></li>
<li><p>Common Techniques:</p>
<ol type="1">
<li><strong>Inverse Distance Weighting (IDW)</strong>: estimate the value of a point based on the values of its neighbours (farther neighbours have less weight)</li>
</ol>
<p><span class="math display">\[\hat{z}(x) = \frac{\sum_{i=1}^{n} w_i(x)z_i}{\sum_{i=1}^{n} w_i(x)}\]</span></p>
<p>where <span class="math inline">\(w_i(x) = \frac{1}{d_i(x)^p}\)</span>, <span class="math inline">\(d_i(x)\)</span> is the distance between <span class="math inline">\(x\)</span> and <span class="math inline">\(i\)</span>, and <span class="math inline">\(p\)</span> is the power parameter</p>
<ol start="2" type="1">
<li><strong>Nearest Neighbour</strong>: estimate the value of a point based on the value of the nearest point (does not consider weights)</li>
</ol>
<ul>
<li>Less smooth than IDW (more jagged)</li>
</ul>
<ol start="3" type="1">
<li><strong>Polynomial Interpolation</strong>: estimate the value of a point based on the values of its neighbours using a polynomial function</li>
<li><strong>Radial Basis Function</strong>: estimate the value of a point based on the values of its neighbours using a radial basis function</li>
</ol></li>
</ul>
</section>
<section id="probabilistic-interpolation" class="level3">
<h3 class="anchored" data-anchor-id="probabilistic-interpolation">Probabilistic Interpolation</h3>
<ul>
<li><strong>Kriging</strong> differs from deterministic because we interpolate using statistical models that include estimates of spatial autocorrelation</li>
</ul>
<p><span class="math display">\[\hat{Z}(s_0) = \sum_{i=1}^{n} \lambda_i Z(s_i)\]</span></p>
<ul>
<li><span class="math inline">\(\lambda_i\)</span> are the weights</li>
<li><span class="math inline">\(Z(s_i)\)</span> are observations at locations <span class="math inline">\(s_i\)</span></li>
<li><span class="math inline">\(N\)</span> is the size of <span class="math inline">\(s\)</span> (number of observations) <br></li>
<li>Kriging uses spatial autocorrelation to estimate the weights
<ul>
<li>Looking at the variance between points to estimate the weights</li>
</ul></li>
</ul>
<section id="variogram" class="level4">
<h4 class="anchored" data-anchor-id="variogram">Variogram</h4>
<ul>
<li>Defines the spatial variance/ autocorrelation between points (as a function of distance)
<ul>
<li>Similar to ACF but for spatial data</li>
</ul></li>
<li>Used to estimate the weights in kriging</li>
<li>e.g.&nbsp;of a function: <span class="math inline">\(\gamma(s_i, s_j) = \frac{1}{2}(Z(s_i) - Z(s_j))^2\)</span>
<ul>
<li>semi-variance because of a factor of 1/2</li>
<li>Each pair is calculated twice</li>
</ul></li>
<li>Plot this function to get the variogram (x-axis: distance, y-axis: semivariance)</li>
</ul>
<p><img src="../images/8_variogram.png" width="300"> <img src="../images/8_semivar.png" width="400"></p>
<ul>
<li><strong>Nugget</strong>: variance at distance 0
<ul>
<li>Ideally should be 0 (no variance at distance 0), higher nugget = more noise</li>
<li>Can be thought of as Random error/ measurement error</li>
</ul></li>
<li><strong>Sill</strong>: maximum variance of spatial process
<ul>
<li>represents the amount of spatial autocorrelation that exists at large enough distances to capture the underlying trend of the process</li>
</ul></li>
<li><strong>Range</strong>: where the semivariance reaches the sill</li>
</ul>
</section>
<section id="kriging-with-pykrige" class="level4">
<h4 class="anchored" data-anchor-id="kriging-with-pykrige">Kriging with <code>pykrige</code></h4>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pykrige.ok <span class="im">import</span> OrdinaryKriging</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>RESOLUTION <span class="op">=</span> <span class="dv">250</span>  <span class="co"># m</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. Convert to meter-based</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>van_listings_gdf <span class="op">=</span> van_listings_gdf.to_crs(<span class="st">"EPSG:3347"</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. Add Easting and Northing columns</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>van_listings_gdf[<span class="st">"Easting"</span>] <span class="op">=</span> van_listings_gdf.geometry.x</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>van_listings_gdf[<span class="st">"Northing"</span>] <span class="op">=</span> van_listings_gdf.geometry.y</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. Create a grid of points</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>gridx <span class="op">=</span> np.arange(van_listings_gdf.bounds.minx.<span class="bu">min</span>(), van_listings_gdf.bounds.maxx.<span class="bu">max</span>(), RESOLUTION)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>gridy <span class="op">=</span> np.arange(an_listings_gdf.bounds.miny.<span class="bu">min</span>(), van_listings_gdf.bounds.maxy.<span class="bu">max</span>(), RESOLUTION)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 4. Kriging</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>krig <span class="op">=</span> OrdinaryKriging(</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span>van_listings_gdf[<span class="st">"Easting"</span>],</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span>van_listings_gdf[<span class="st">"Northing"</span>],</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    z<span class="op">=</span>van_listings_gdf[<span class="st">"price"</span>],</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    variogram_model<span class="op">=</span><span class="st">"spherical"</span>)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="co"># 5. Execute and plot</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>z, ss <span class="op">=</span> krig.execute(<span class="st">"grid"</span>, gridx, gridy)</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>plt.imshow(z)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="areal-interpolation" class="level3">
<h3 class="anchored" data-anchor-id="areal-interpolation">Areal Interpolation</h3>
<ul>
<li>Project data from one set of polygons to another set of polygons</li>
<li>E.g. Map air pollution data fo FSA (“forward sortation area”, which are groups of postal codes) polygons</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load the FSA data</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>van_fsa <span class="op">=</span> gpd.read_file(<span class="st">"data-spatial/van-fsa"</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Kriging (similar to previous cell)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>pm25_model <span class="op">=</span> gpd.GeoDataFrame({<span class="st">"PM_25_modelled"</span>: values}, geometry<span class="op">=</span>polygons, crs<span class="op">=</span><span class="st">"EPSG:3347"</span>).to_crs(<span class="st">"EPSG:4326"</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>z, ss <span class="op">=</span> krig.execute(<span class="st">"grid"</span>, gridx, gridy)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Areal Interpolation</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>areal_interp <span class="op">=</span> area_interpolate(pm25_model.to_crs(<span class="st">"EPSG:3347"</span>),</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>                                van_fsa.to_crs(<span class="st">"EPSG:3347"</span>),</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>                                intensive_variables<span class="op">=</span>[<span class="st">"PM_25_modelled"</span>]).to_crs(<span class="st">"EPSG:4326"</span>)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>areal_interp.plot(column<span class="op">=</span><span class="st">"PM_25_modelled"</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">8</span>),</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>                  edgecolor<span class="op">=</span><span class="st">"0.2"</span>, cmap<span class="op">=</span><span class="st">"RdBu"</span>, legend<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><img src="../images/8_area_inter.png" width="300"></p>
</section>
<section id="shortest-path-analysis" class="level3">
<h3 class="anchored" data-anchor-id="shortest-path-analysis">Shortest Path Analysis</h3>
<ul>
<li>Use <strong>Dijkstra’s algorithm</strong> to find the shortest path between two points</li>
<li>Condition:
<ul>
<li>The graph must be weighted with non-negative weights</li>
</ul></li>
<li><strong>Algorithm</strong>:
<ol type="1">
<li>Label start node with 0, all others with infinity</li>
<li>Label current node as visited</li>
<li>Go to all connected nodes (to current) and update label with <code>min(current_label, previous_label + weight)</code></li>
</ol>
<ul>
<li>If updated, then keep track of the previous node (for backtracking later)</li>
</ul>
<ol start="4" type="1">
<li>Once all nodes around the current node are visited, go to the unvisited node with the smallest label and repeat step 2</li>
<li>Backtrack from end node to start node using the previous node</li>
</ol></li>
<li>Time complexity: <span class="math inline">\(O(V^2)\)</span> but its <span class="math inline">\(O(E + V \log V)\)</span> with a min-priority queue/ binary heap</li>
<li>Space complexity: <span class="math inline">\(O(V)\)</span></li>
</ul>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> osmnx <span class="im">as</span> ox</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Origin</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>orig_address <span class="op">=</span> <span class="st">"UBC bookstore, Vancouver"</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>orig_y, orig_x <span class="op">=</span> ox.geocode(orig_address)  <span class="co"># notice the coordinate order (y, x)!</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Destination</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>dest_address <span class="op">=</span> <span class="st">"Orchard Commons Student Residence, Vancouver"</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>dest_y, dest_x <span class="op">=</span> ox.geocode(dest_address)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Find the nearest nodes</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>orig_node_id, dist_to_orig <span class="op">=</span> ox.distance.nearest_nodes(G, X<span class="op">=</span>orig_x, Y<span class="op">=</span>orig_y, return_dist<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>dest_node_id, dist_to_dest <span class="op">=</span> ox.distance.nearest_nodes(G, X<span class="op">=</span>dest_x, Y<span class="op">=</span>dest_y, return_dist<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Find the shortest path</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>route <span class="op">=</span> nx.shortest_path(G, orig_node_id, dest_node_id, weight<span class="op">=</span><span class="st">"length"</span>)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the shortest path</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>ox.plot.plot_graph_route(G, route)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>